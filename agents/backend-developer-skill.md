# Backend Developer Agent - Skill Definition

## Agent Identity
**Role**: Backend Developer  
**Responsibility**: Build RESTful API with ASP.NET Core 10, feature-based architecture, LLBLGen Pro integration  
**Tech Stack**: ASP.NET Core 10, C# 12, LLBLGen Pro (Adapter), PostgreSQL, Fluent Migrator, AutoMapper

## Core Competencies

### 1. ASP.NET Core Development
- **Web API Development**: RESTful API design and implementation
- **Feature-Based Architecture**: Vertical slices organized by domain entity
- **Dependency Injection**: Built-in DI container
- **Middleware**: Custom middleware for logging, error handling, localization
- **Authentication & Authorization**: JWT tokens, role-based access control
- **API Versioning**: URL-based versioning (/api/v1/)

### 2. Project Architecture (3-Project Solution)

```
ECommerce.sln
├── ECommerce.API/                    # Presentation Layer
│   ├── Controllers/
│   ├── Middleware/
│   ├── Program.cs
│   └── appsettings.json
│
├── ECommerce.Core/                   # Business Logic & Repository Interfaces
│   ├── Features/                     # Feature folders per domain entity
│   │   ├── Area/
│   │   │   ├── IAreaRepository.cs
│   │   │   ├── AreaRepository.cs
│   │   │   ├── AreaService.cs
│   │   │   ├── AreaFilter.cs
│   │   │   ├── AreaInputs.cs
│   │   │   └── AreaOutputs.cs
│   │   ├── Product/
│   │   │   ├── IProductRepository.cs
│   │   │   ├── ProductRepository.cs
│   │   │   ├── ProductService.cs
│   │   │   ├── ProductFilter.cs
│   │   │   ├── ProductInputs.cs
│   │   │   └── ProductOutputs.cs
│   │   ├── Order/
│   │   ├── Cart/
│   │   ├── User/
│   │   └── ... (other features)
│   ├── Resources/                    # Localization
│   │   ├── Common/
│   │   │   ├── en.json
│   │   │   └── ar.json
│   │   └── Features/
│   │       ├── Area.en.json
│   │       ├── Area.ar.json
│   │       ├── Product.en.json
│   │       └── Product.ar.json
│   ├── Misc/                         # SK Framework (to be added)
│   │   ├── Extensions/
│   │   ├── Helpers/
│   │   └── BaseClasses/
│   └── Common/                       # Shared interfaces and base classes
│       ├── IRepository.cs
│       ├── BaseRepository.cs
│       └── ServiceResult.cs
│
└── ECommerce.Data/                   # Data Layer (LLBLGen Pro + Migrations)
    ├── Entities/                     # LLBLGen Pro generated entities
    │   └── (Generated by LLBLGen)
    ├── Views/                        # LLBLGen Pro generated view entities
    │   └── (Generated by LLBLGen)
    ├── DatabaseSpecific/             # LLBLGen Pro adapter code
    │   └── (Generated by LLBLGen)
    ├── Migrations/                   # Fluent Migrator scripts
    │   ├── V1_AddInitialTables.cs
    │   ├── V2_AddProductCategories.cs
    │   └── V3_AddOrderTables.cs
    └── Scripts/                      # Custom SQL scripts
        └── SeedData.sql
```

### 3. LLBLGen Pro (Adapter Pattern)
- **Adapter Pattern**: Entities are POCOs, separate from persistence logic
- **DataAccessAdapter**: Central database access point
- **Entity Classes**: Generated from PostgreSQL database schema
- **TypedView Classes**: For complex queries and database views
- **Prefetch Paths**: Eager loading related entities
- **Dynamic Lists**: Build complex queries programmatically

## Technology Stack Details

### Core Dependencies
```xml
<!-- ECommerce.API -->
<ItemGroup>
  <PackageReference Include="Microsoft.AspNetCore.Authentication.JwtBearer" Version="8.0.0" />
  <PackageReference Include="Swashbuckle.AspNetCore" Version="6.5.0" />
  <PackageReference Include="Serilog.AspNetCore" Version="8.0.0" />
  <PackageReference Include="Microsoft.Extensions.Localization" Version="8.0.0" />
</ItemGroup>

<!-- ECommerce.Core -->
<ItemGroup>
  <PackageReference Include="AutoMapper" Version="12.0.0" />
  <PackageReference Include="FluentValidation" Version="11.8.0" />
  <PackageReference Include="Stripe.net" Version="43.0.0" />
</ItemGroup>

<!-- ECommerce.Data -->
<ItemGroup>
  <PackageReference Include="SD.LLBLGen.Pro.ORMSupportClasses" Version="5.10.0" />
  <PackageReference Include="SD.LLBLGen.Pro.DQE.PostgreSql" Version="5.10.0" />
  <PackageReference Include="FluentMigrator" Version="5.0.0" />
  <PackageReference Include="FluentMigrator.Runner" Version="5.0.0" />
  <PackageReference Include="FluentMigrator.Runner.Postgres" Version="5.0.0" />
  <PackageReference Include="Npgsql" Version="8.0.0" />
</ItemGroup>
```

## Feature-Based Structure Pattern

### Each Feature Folder Contains:

#### 1. Repository Interface (IAreaRepository.cs)
```csharp
namespace ECommerce.Core.Features.Area;

public interface IAreaRepository : IRepository<AreaEntity>
{
    Task<AreaEntity?> GetByIdAsync(int id);
    Task<List<AreaEntity>> GetAllAsync(AreaFilter filter);
    Task<AreaEntity> CreateAsync(AreaEntity entity);
    Task<AreaEntity> UpdateAsync(AreaEntity entity);
    Task DeleteAsync(int id);
    Task<bool> ExistsAsync(int id);
    Task<int> CountAsync(AreaFilter filter);
}
```

#### 2. Repository Implementation (AreaRepository.cs)
```csharp
using SD.LLBLGen.Pro.ORMSupportClasses;
using SD.LLBLGen.Pro.LinqSupportClasses;
using ECommerce.Data.Entities;
using ECommerce.Data.DatabaseSpecific;

namespace ECommerce.Core.Features.Area;

public class AreaRepository : BaseRepository<AreaEntity>, IAreaRepository
{
    public AreaRepository(IDataAccessAdapterFactory adapterFactory) 
        : base(adapterFactory)
    {
    }

    public async Task<AreaEntity?> GetByIdAsync(int id)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        var area = new AreaEntity(id);
        
        if (await adapter.FetchEntityAsync(area))
        {
            return area;
        }
        
        return null;
    }

    public async Task<List<AreaEntity>> GetAllAsync(AreaFilter filter)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        using var metaData = new LinqMetaData(adapter);
        
        var query = metaData.Area.AsQueryable();

        // Apply filters
        if (!string.IsNullOrEmpty(filter.Name))
        {
            query = query.Where(a => a.Name.Contains(filter.Name));
        }

        if (filter.IsActive.HasValue)
        {
            query = query.Where(a => a.IsActive == filter.IsActive.Value);
        }

        // Pagination
        if (filter.PageSize > 0)
        {
            query = query
                .Skip((filter.PageNumber - 1) * filter.PageSize)
                .Take(filter.PageSize);
        }

        return await query.ToListAsync();
    }

    public async Task<AreaEntity> CreateAsync(AreaEntity entity)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        entity.IsNew = true;
        entity.CreatedAt = DateTime.UtcNow;
        entity.UpdatedAt = DateTime.UtcNow;
        
        await adapter.SaveEntityAsync(entity);
        return entity;
    }

    public async Task<AreaEntity> UpdateAsync(AreaEntity entity)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        entity.UpdatedAt = DateTime.UtcNow;
        
        await adapter.SaveEntityAsync(entity);
        return entity;
    }

    public async Task DeleteAsync(int id)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        var area = new AreaEntity(id);
        
        await adapter.DeleteEntityAsync(area);
    }

    public async Task<bool> ExistsAsync(int id)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        using var metaData = new LinqMetaData(adapter);
        
        return await metaData.Area.AnyAsync(a => a.Id == id);
    }

    public async Task<int> CountAsync(AreaFilter filter)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        using var metaData = new LinqMetaData(adapter);
        
        var query = metaData.Area.AsQueryable();

        if (!string.IsNullOrEmpty(filter.Name))
        {
            query = query.Where(a => a.Name.Contains(filter.Name));
        }

        if (filter.IsActive.HasValue)
        {
            query = query.Where(a => a.IsActive == filter.IsActive.Value);
        }

        return await query.CountAsync();
    }
}
```

#### 3. Service Layer (AreaService.cs)
```csharp
using AutoMapper;
using Microsoft.Extensions.Localization;

namespace ECommerce.Core.Features.Area;

public class AreaService
{
    private readonly IAreaRepository _repository;
    private readonly IMapper _mapper;
    private readonly IStringLocalizer<AreaService> _localizer;
    private readonly ILogger<AreaService> _logger;

    public AreaService(
        IAreaRepository repository,
        IMapper mapper,
        IStringLocalizer<AreaService> localizer,
        ILogger<AreaService> logger)
    {
        _repository = repository;
        _mapper = mapper;
        _localizer = localizer;
        _logger = logger;
    }

    public async Task<ServiceResult<AreaOutput>> GetByIdAsync(int id)
    {
        var entity = await _repository.GetByIdAsync(id);
        
        if (entity == null)
        {
            return ServiceResult<AreaOutput>.Failure(
                _localizer["AreaNotFound"].Value);
        }

        var output = _mapper.Map<AreaOutput>(entity);
        return ServiceResult<AreaOutput>.Success(output);
    }

    public async Task<ServiceResult<PagedResult<AreaListOutput>>> GetAllAsync(AreaFilter filter)
    {
        var entities = await _repository.GetAllAsync(filter);
        var totalCount = await _repository.CountAsync(filter);

        var outputs = _mapper.Map<List<AreaListOutput>>(entities);
        
        var pagedResult = new PagedResult<AreaListOutput>
        {
            Items = outputs,
            TotalCount = totalCount,
            PageNumber = filter.PageNumber,
            PageSize = filter.PageSize
        };

        return ServiceResult<PagedResult<AreaListOutput>>.Success(pagedResult);
    }

    public async Task<ServiceResult<AreaOutput>> CreateAsync(CreateAreaInput input)
    {
        // Validation
        if (string.IsNullOrWhiteSpace(input.Name))
        {
            return ServiceResult<AreaOutput>.Failure(
                _localizer["AreaNameRequired"].Value);
        }

        var entity = _mapper.Map<AreaEntity>(input);
        var created = await _repository.CreateAsync(entity);

        _logger.LogInformation("Area created with ID: {AreaId}", created.Id);

        var output = _mapper.Map<AreaOutput>(created);
        return ServiceResult<AreaOutput>.Success(output);
    }

    public async Task<ServiceResult<AreaOutput>> UpdateAsync(int id, UpdateAreaInput input)
    {
        var existing = await _repository.GetByIdAsync(id);
        
        if (existing == null)
        {
            return ServiceResult<AreaOutput>.Failure(
                _localizer["AreaNotFound"].Value);
        }

        _mapper.Map(input, existing);
        var updated = await _repository.UpdateAsync(existing);

        var output = _mapper.Map<AreaOutput>(updated);
        return ServiceResult<AreaOutput>.Success(output);
    }

    public async Task<ServiceResult<bool>> DeleteAsync(int id)
    {
        var exists = await _repository.ExistsAsync(id);
        
        if (!exists)
        {
            return ServiceResult<bool>.Failure(
                _localizer["AreaNotFound"].Value);
        }

        await _repository.DeleteAsync(id);
        
        _logger.LogInformation("Area deleted with ID: {AreaId}", id);
        
        return ServiceResult<bool>.Success(true);
    }
}
```

#### 4. Filter Classes (AreaFilter.cs)
```csharp
namespace ECommerce.Core.Features.Area;

/// <summary>
/// Filter/query parameters for Area search and list operations
/// </summary>
public class AreaFilter
{
    public string? Name { get; set; }
    public bool? IsActive { get; set; }
    public DateTime? CreatedAfter { get; set; }
    public DateTime? CreatedBefore { get; set; }
    
    // Pagination
    public int PageNumber { get; set; } = 1;
    public int PageSize { get; set; } = 10;
    
    // Sorting
    public string? SortBy { get; set; } = "Name";
    public bool SortDescending { get; set; } = false;
}
```

#### 5. Input DTOs (AreaInputs.cs)
```csharp
using System.ComponentModel.DataAnnotations;

namespace ECommerce.Core.Features.Area;

/// <summary>
/// DTO for creating a new Area
/// </summary>
public class CreateAreaInput
{
    [Required]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(500)]
    public string? Description { get; set; }

    public bool IsActive { get; set; } = true;
}

/// <summary>
/// DTO for updating an existing Area
/// </summary>
public class UpdateAreaInput
{
    [Required]
    [MaxLength(100)]
    public string Name { get; set; } = string.Empty;

    [MaxLength(500)]
    public string? Description { get; set; }

    public bool IsActive { get; set; }
}
```

#### 6. Output DTOs (AreaOutputs.cs)
```csharp
namespace ECommerce.Core.Features.Area;

/// <summary>
/// Full Area details output (for single item retrieval)
/// </summary>
public class AreaOutput
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public string? Description { get; set; }
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
    public DateTime UpdatedAt { get; set; }
}

/// <summary>
/// Simplified Area output for list views
/// </summary>
public class AreaListOutput
{
    public int Id { get; set; }
    public string Name { get; set; } = string.Empty;
    public bool IsActive { get; set; }
    public DateTime CreatedAt { get; set; }
}
```

## Base Repository Pattern

### Common/IRepository.cs
```csharp
namespace ECommerce.Core.Common;

public interface IRepository<TEntity> where TEntity : class
{
    // Base interface - can be empty or contain very common methods
    // Specific repositories inherit and add their own methods
}
```

### Common/BaseRepository.cs
```csharp
using SD.LLBLGen.Pro.ORMSupportClasses;

namespace ECommerce.Core.Common;

public abstract class BaseRepository<TEntity> : IRepository<TEntity> 
    where TEntity : class
{
    protected readonly IDataAccessAdapterFactory _adapterFactory;

    protected BaseRepository(IDataAccessAdapterFactory adapterFactory)
    {
        _adapterFactory = adapterFactory;
    }

    // Common helper methods can go here
    protected async Task<bool> SaveEntityAsync(IEntity2 entity)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        return await adapter.SaveEntityAsync(entity);
    }

    protected async Task<bool> DeleteEntityAsync(IEntity2 entity)
    {
        using var adapter = _adapterFactory.CreateAdapter();
        return await adapter.DeleteEntityAsync(entity);
    }
}
```

### Common/ServiceResult.cs
```csharp
namespace ECommerce.Core.Common;

public class ServiceResult<T>
{
    public bool IsSuccess { get; set; }
    public T? Data { get; set; }
    public string? ErrorMessage { get; set; }
    public List<string> Errors { get; set; } = new();

    public static ServiceResult<T> Success(T data)
    {
        return new ServiceResult<T>
        {
            IsSuccess = true,
            Data = data
        };
    }

    public static ServiceResult<T> Failure(string errorMessage)
    {
        return new ServiceResult<T>
        {
            IsSuccess = false,
            ErrorMessage = errorMessage,
            Errors = new List<string> { errorMessage }
        };
    }

    public static ServiceResult<T> Failure(List<string> errors)
    {
        return new ServiceResult<T>
        {
            IsSuccess = false,
            Errors = errors,
            ErrorMessage = string.Join(", ", errors)
        };
    }
}

public class PagedResult<T>
{
    public List<T> Items { get; set; } = new();
    public int TotalCount { get; set; }
    public int PageNumber { get; set; }
    public int PageSize { get; set; }
    public int TotalPages => (int)Math.Ceiling(TotalCount / (double)PageSize);
    public bool HasPreviousPage => PageNumber > 1;
    public bool HasNextPage => PageNumber < TotalPages;
}
```

## Fluent Migrator Patterns

### Migration Structure
```csharp
// ECommerce.Data/Migrations/V1_AddInitialTables.cs
using FluentMigrator;

namespace ECommerce.Data.Migrations;

[Migration(1, "Add initial tables for users, products, categories")]
public class V1_AddInitialTables : Migration
{
    public override void Up()
    {
        // Create Users table
        Create.Table("users")
            .WithColumn("id").AsInt32().PrimaryKey().Identity()
            .WithColumn("email").AsString(255).NotNullable().Unique()
            .WithColumn("password_hash").AsString(500).NotNullable()
            .WithColumn("first_name").AsString(100).NotNullable()
            .WithColumn("last_name").AsString(100).NotNullable()
            .WithColumn("role").AsString(50).NotNullable().WithDefaultValue("Customer")
            .WithColumn("is_active").AsBoolean().NotNullable().WithDefaultValue(true)
            .WithColumn("created_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime)
            .WithColumn("updated_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime);

        // Create Categories table
        Create.Table("categories")
            .WithColumn("id").AsInt32().PrimaryKey().Identity()
            .WithColumn("name").AsString(100).NotNullable()
            .WithColumn("description").AsString(500).Nullable()
            .WithColumn("parent_category_id").AsInt32().Nullable()
            .WithColumn("is_active").AsBoolean().NotNullable().WithDefaultValue(true)
            .WithColumn("created_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime)
            .WithColumn("updated_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime);

        // Foreign key for parent category
        Create.ForeignKey("fk_categories_parent")
            .FromTable("categories").ForeignColumn("parent_category_id")
            .ToTable("categories").PrimaryColumn("id");

        // Create Products table
        Create.Table("products")
            .WithColumn("id").AsInt32().PrimaryKey().Identity()
            .WithColumn("name").AsString(200).NotNullable()
            .WithColumn("description").AsString(2000).Nullable()
            .WithColumn("price").AsDecimal(10, 2).NotNullable()
            .WithColumn("stock_quantity").AsInt32().NotNullable().WithDefaultValue(0)
            .WithColumn("category_id").AsInt32().Nullable()
            .WithColumn("image_url").AsString(500).Nullable()
            .WithColumn("is_active").AsBoolean().NotNullable().WithDefaultValue(true)
            .WithColumn("created_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime)
            .WithColumn("updated_at").AsDateTime().NotNullable().WithDefault(SystemMethods.CurrentUTCDateTime);

        // Foreign key for category
        Create.ForeignKey("fk_products_category")
            .FromTable("products").ForeignColumn("category_id")
            .ToTable("categories").PrimaryColumn("id");

        // Indexes
        Create.Index("idx_products_name")
            .OnTable("products")
            .OnColumn("name");

        Create.Index("idx_products_category")
            .OnTable("products")
            .OnColumn("category_id");
    }

    public override void Down()
    {
        Delete.Table("products");
        Delete.Table("categories");
        Delete.Table("users");
    }
}
```

### Migration with View Creation
```csharp
[Migration(5, "Add product inventory view")]
public class V5_AddProductInventoryView : Migration
{
    public override void Up()
    {
        Execute.Sql(@"
            CREATE OR REPLACE VIEW product_inventory_view AS
            SELECT 
                p.id,
                p.name,
                p.price,
                p.stock_quantity,
                c.name AS category_name,
                CASE 
                    WHEN p.stock_quantity = 0 THEN 'Out of Stock'
                    WHEN p.stock_quantity < 10 THEN 'Low Stock'
                    ELSE 'In Stock'
                END AS stock_status
            FROM products p
            LEFT JOIN categories c ON p.category_id = c.id
            WHERE p.is_active = true;
        ");
    }

    public override void Down()
    {
        Execute.Sql("DROP VIEW IF EXISTS product_inventory_view;");
    }
}
```

## Localization Setup

### Resource Files Structure
```
Resources/
├── Common/
│   ├── en.json              # Common English resources
│   └── ar.json              # Common Arabic resources
└── Features/
    ├── Area.en.json         # Area-specific English
    ├── Area.ar.json         # Area-specific Arabic
    ├── Product.en.json
    ├── Product.ar.json
    ├── Order.en.json
    └── Order.ar.json
```

### Common/en.json
```json
{
  "ValidationError": "Validation error occurred",
  "NotFound": "Resource not found",
  "Unauthorized": "You are not authorized to perform this action",
  "ServerError": "An internal server error occurred",
  "SuccessMessage": "Operation completed successfully",
  "Required": "This field is required",
  "InvalidEmail": "Invalid email address",
  "InvalidFormat": "Invalid format"
}
```

### Common/ar.json
```json
{
  "ValidationError": "حدث خطأ في التحقق",
  "NotFound": "المورد غير موجود",
  "Unauthorized": "غير مصرح لك بتنفيذ هذا الإجراء",
  "ServerError": "حدث خطأ داخلي في الخادم",
  "SuccessMessage": "تمت العملية بنجاح",
  "Required": "هذا الحقل مطلوب",
  "InvalidEmail": "عنوان بريد إلكتروني غير صالح",
  "InvalidFormat": "تنسيق غير صالح"
}
```

### Features/Area.en.json
```json
{
  "AreaNotFound": "Area not found",
  "AreaNameRequired": "Area name is required",
  "AreaCreated": "Area created successfully",
  "AreaUpdated": "Area updated successfully",
  "AreaDeleted": "Area deleted successfully",
  "AreaAlreadyExists": "An area with this name already exists"
}
```

### Localization Configuration (Program.cs)
```csharp
// Add localization services
builder.Services.AddLocalization();
builder.Services.Configure<RequestLocalizationOptions>(options =>
{
    var supportedCultures = new[] { "en", "ar" };
    options.SetDefaultCulture("en")
        .AddSupportedCultures(supportedCultures)
        .AddSupportedUICultures(supportedCultures);
});

// Custom JSON string localizer
builder.Services.AddSingleton<IStringLocalizerFactory, JsonStringLocalizerFactory>();

// After app is built
var localizationOptions = app.Services.GetRequiredService<IOptions<RequestLocalizationOptions>>();
app.UseRequestLocalization(localizationOptions.Value);
```

## AutoMapper Configuration

```csharp
// ECommerce.Core/Features/Area/AreaMappingProfile.cs
using AutoMapper;
using ECommerce.Data.Entities;

namespace ECommerce.Core.Features.Area;

public class AreaMappingProfile : Profile
{
    public AreaMappingProfile()
    {
        // Entity to Output
        CreateMap<AreaEntity, AreaOutput>();
        CreateMap<AreaEntity, AreaListOutput>();

        // Input to Entity
        CreateMap<CreateAreaInput, AreaEntity>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore());

        CreateMap<UpdateAreaInput, AreaEntity>()
            .ForMember(dest => dest.Id, opt => opt.Ignore())
            .ForMember(dest => dest.CreatedAt, opt => opt.Ignore())
            .ForMember(dest => dest.UpdatedAt, opt => opt.Ignore());
    }
}

// Register all mapping profiles in Program.cs
builder.Services.AddAutoMapper(typeof(AreaMappingProfile).Assembly);
```

## Controller Example

```csharp
// ECommerce.API/Controllers/AreasController.cs
using Microsoft.AspNetCore.Mvc;
using Microsoft.AspNetCore.Authorization;
using ECommerce.Core.Features.Area;

namespace ECommerce.API.Controllers;

[ApiController]
[Route("api/v1/[controller]")]
public class AreasController : ControllerBase
{
    private readonly AreaService _areaService;

    public AreasController(AreaService areaService)
    {
        _areaService = areaService;
    }

    [HttpGet]
    [ProducesResponseType(typeof(PagedResult<AreaListOutput>), StatusCodes.Status200OK)]
    public async Task<IActionResult> GetAll([FromQuery] AreaFilter filter)
    {
        var result = await _areaService.GetAllAsync(filter);
        
        if (!result.IsSuccess)
        {
            return BadRequest(result.ErrorMessage);
        }

        return Ok(result.Data);
    }

    [HttpGet("{id}")]
    [ProducesResponseType(typeof(AreaOutput), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> GetById(int id)
    {
        var result = await _areaService.GetByIdAsync(id);
        
        if (!result.IsSuccess)
        {
            return NotFound(result.ErrorMessage);
        }

        return Ok(result.Data);
    }

    [HttpPost]
    [Authorize(Roles = "Admin,SuperAdmin")]
    [ProducesResponseType(typeof(AreaOutput), StatusCodes.Status201Created)]
    [ProducesResponseType(StatusCodes.Status400BadRequest)]
    public async Task<IActionResult> Create([FromBody] CreateAreaInput input)
    {
        var result = await _areaService.CreateAsync(input);
        
        if (!result.IsSuccess)
        {
            return BadRequest(result.ErrorMessage);
        }

        return CreatedAtAction(nameof(GetById), new { id = result.Data!.Id }, result.Data);
    }

    [HttpPut("{id}")]
    [Authorize(Roles = "Admin,SuperAdmin")]
    [ProducesResponseType(typeof(AreaOutput), StatusCodes.Status200OK)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Update(int id, [FromBody] UpdateAreaInput input)
    {
        var result = await _areaService.UpdateAsync(id, input);
        
        if (!result.IsSuccess)
        {
            return NotFound(result.ErrorMessage);
        }

        return Ok(result.Data);
    }

    [HttpDelete("{id}")]
    [Authorize(Roles = "SuperAdmin")]
    [ProducesResponseType(StatusCodes.Status204NoContent)]
    [ProducesResponseType(StatusCodes.Status404NotFound)]
    public async Task<IActionResult> Delete(int id)
    {
        var result = await _areaService.DeleteAsync(id);
        
        if (!result.IsSuccess)
        {
            return NotFound(result.ErrorMessage);
        }

        return NoContent();
    }
}
```

## LLBLGen Pro Setup Guide

### 1. Project Creation
1. Create new LLBLGen Pro project
2. Select PostgreSQL as database type
3. Choose **Adapter** template
4. Set target framework: .NET 8.0
5. Configure connection string to PostgreSQL database

### 2. Entity Generation
1. Refresh database catalog
2. Select tables, views, and stored procedures
3. Generate entities to `ECommerce.Data/Entities/`
4. Generate database-specific code to `ECommerce.Data/DatabaseSpecific/`

### 3. Naming Conventions
- **Table naming**: lowercase_with_underscores (PostgreSQL convention)
- **Entity naming**: PascalCase (C# convention)
- **Field naming**: PascalCase in entities
- Example: `product_categories` table → `ProductCategoryEntity` class

### 4. Configuration
```xml
<!-- LLBLGenPro.config -->
<project>
  <targetPerEntityEdge>Adapter</targetPerEntityEdge>
  <rootNamespace>ECommerce.Data</rootNamespace>
  <databaseType>PostgreSQL</databaseType>
</project>
```

## Dependency Injection Setup (Program.cs)

```csharp
// Data Layer - LLBLGen Pro
builder.Services.AddSingleton<IDataAccessAdapterFactory>(sp =>
{
    var connectionString = builder.Configuration.GetConnectionString("DefaultConnection");
    return new DataAccessAdapterFactory(connectionString!);
});

// Core Layer - Repositories and Services (Auto-register by convention)
var coreAssembly = typeof(IAreaRepository).Assembly;

// Register all repositories
builder.Services.Scan(scan => scan
    .FromAssemblies(coreAssembly)
    .AddClasses(classes => classes.AssignableTo(typeof(IRepository<>)))
    .AsImplementedInterfaces()
    .WithScopedLifetime());

// Register all services
builder.Services.Scan(scan => scan
    .FromAssemblies(coreAssembly)
    .AddClasses(classes => classes.Where(t => t.Name.EndsWith("Service")))
    .AsSelf()
    .WithScopedLifetime());

// AutoMapper
builder.Services.AddAutoMapper(coreAssembly);

// Fluent Migrator
builder.Services.AddFluentMigratorCore()
    .ConfigureRunner(rb => rb
        .AddPostgres()
        .WithGlobalConnectionString(builder.Configuration.GetConnectionString("DefaultConnection"))
        .ScanIn(typeof(V1_AddInitialTables).Assembly).For.Migrations())
    .AddLogging(lb => lb.AddFluentMigratorConsole());
```

## SK Framework Placeholder

```
Misc/
├── Extensions/                 # Extension methods
│   ├── StringExtensions.cs
│   ├── DateTimeExtensions.cs
│   └── QueryableExtensions.cs
├── Helpers/                    # Utility helpers
│   ├── CryptographyHelper.cs
│   ├── ValidationHelper.cs
│   └── FileHelper.cs
└── BaseClasses/                # Abstract base classes
    ├── BaseEntity.cs
    ├── BaseService.cs
    └── BaseValidator.cs
```

**Note**: The SK framework will be provided later and integrated into the Misc folder. The backend agent should document the folder structure and leave it ready for integration.

## Testing Strategy

### Unit Tests (xUnit)
```csharp
public class AreaServiceTests
{
    private readonly Mock<IAreaRepository> _mockRepository;
    private readonly Mock<IMapper> _mockMapper;
    private readonly Mock<IStringLocalizer<AreaService>> _mockLocalizer;
    private readonly AreaService _service;

    public AreaServiceTests()
    {
        _mockRepository = new Mock<IAreaRepository>();
        _mockMapper = new Mock<IMapper>();
        _mockLocalizer = new Mock<IStringLocalizer<AreaService>>();
        _service = new AreaService(_mockRepository.Object, _mockMapper.Object, 
            _mockLocalizer.Object, Mock.Of<ILogger<AreaService>>());
    }

    [Fact]
    public async Task GetByIdAsync_AreaExists_ReturnsSuccess()
    {
        // Arrange
        var entity = new AreaEntity { Id = 1, Name = "Test Area" };
        var output = new AreaOutput { Id = 1, Name = "Test Area" };
        
        _mockRepository.Setup(r => r.GetByIdAsync(1)).ReturnsAsync(entity);
        _mockMapper.Setup(m => m.Map<AreaOutput>(entity)).Returns(output);

        // Act
        var result = await _service.GetByIdAsync(1);

        // Assert
        Assert.True(result.IsSuccess);
        Assert.NotNull(result.Data);
        Assert.Equal("Test Area", result.Data.Name);
    }
}
```

## Git Workflow
- **Branch Naming**: `feature/backend/[feature-name]`
- **Commit Messages**: Conventional commits format
- **Pull Requests**: Include migration scripts, test results

## Deliverables
- [ ] ASP.NET Core 10 API project setup
- [ ] Feature-based folder structure for all domains
- [ ] LLBLGen Pro integration and entity generation
- [ ] Fluent Migrator scripts for all tables
- [ ] Repository implementations with LLBLGen Pro Adapter
- [ ] Service layer with business logic
- [ ] AutoMapper profiles for all features
- [ ] Localization setup (en/ar JSON files)
- [ ] JWT authentication & authorization
- [ ] Stripe payment integration
- [ ] Unit tests for services
- [ ] Integration tests for API endpoints
- [ ] Swagger documentation

## Success Criteria
- Feature-based architecture properly implemented
- LLBLGen Pro entities generated and integrated
- All migrations execute successfully
- Localization working for both languages
- Test coverage > 80%
- API documentation complete
- Zero security vulnerabilities
